<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/guoliangjun.github.io/1748/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-split命令</title>
    <url>/guoliangjun.github.io/1742/</url>
    <content><![CDATA[<p>功能说明：切割文件。</p>
<p>语　　法：split [–help][–version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</p>
<p>补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。</p>
<p>参　　数：</p>
<p>-&lt;行数&gt;或-l&lt;行数&gt; 　指定每多少行就要切成一个小文件。</p>
<p>-b&lt;字节&gt; 　指定每多少字就要切成一个小文件。支持单位:m,k</p>
<p>-C&lt;字节&gt; 　与-b参数类似，但切割时尽量维持每行的完整性。</p>
<p>–help 　显示帮助。</p>
<p>–version 　显示版本信息。</p>
<p>[输出文件名] 　设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。</p>
<p>使用例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split -b 100m 1111.log (按照字节分隔)</span><br><span class="line">split -l 1000000 1111.log(按照行数分隔)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>split</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>split</tag>
      </tags>
  </entry>
  <entry>
    <title>内网机器使用frp实现内网穿透(centos)</title>
    <url>/guoliangjun.github.io/1739/</url>
    <content><![CDATA[<p>现在大部分家里的宽带都没有独立的公网ip，没有公网IP是一件很不方便的事情，为了解决这个问题，则需要内网穿透，而内网穿透的方法有很多种，例如使用<code>花生壳</code>、<code>ngrok</code>等，该文章要介绍的是使用frp让家里的机器实现内网穿透。</p>
<p><strong>实际上frp有官方的<a href="https://gofrp.org/docs/">中文文档(https://gofrp.org/docs/)</a>，上面的内容已经非常详尽，对相关操作比较熟悉的人可以直接阅读官方的中文文档。</strong></p>
<h3 id="什么是frp"><a href="#什么是frp" class="headerlink" title="什么是frp"></a>什么是frp</h3><blockquote>
<p><a href="https://links.jianshu.com/go?to=https://github.com/fatedier/frp">frp</a> 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在使用frp之前，需要一台有公网IP的服务器（下文称外网主机），一台需要实现内网穿透的机器（下文称内网主机），SSH工具，以及一个域名（如果只是建立SSH反向代理则不需要域名）。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>根据机器的操作系统，在<a href="https://github.com/fatedier/frp/releases">Release</a>页面中找到对应的frp程序，然后分别在外网主机和内网主机中下载它。</p>
<p>我这边使用的是：frp_0.36.2_linux_amd64.tar</p>
<h6 id="外网服务器-外网主机"><a href="#外网服务器-外网主机" class="headerlink" title="外网服务器-外网主机"></a>外网服务器-外网主机</h6><p>SSH连接上外网主机后，使用<code>wget</code>指令下载frp或者直接本机下载完后上传到外网主机。</p>
<p>使用<code>tar</code>指令解压tar.gz文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.36.2_linux_amd64.tar</span><br></pre></td></tr></table></figure>

<p>使用<code>cd</code>指令进入解压出来的文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frp_0.36.2_linux_amd64/</span><br></pre></td></tr></table></figure>

<p>外网主机作为服务端，可以删掉不必要的客户端文件，使用<code>rm</code>指令删除文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f frpc</span><br><span class="line">rm -f frpc.ini</span><br></pre></td></tr></table></figure>

<p>接下来要修改服务器配置文件，即<code>frps.ini</code>文件。使用<code>vi</code>指令对目标文件进行编辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 17000 #默认是7000</span><br></pre></td></tr></table></figure>

<p><code>[common]</code>部分是必须有的配置，其中<code>bind_port</code>是自己设定的frp服务端端口</p>
<p>保存上面的配置后，使用以下指令后台启动frp服务端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>服务端的工作就到此结束了。</p>
<h6 id="内网机器-客户端"><a href="#内网机器-客户端" class="headerlink" title="内网机器-客户端"></a>内网机器-客户端</h6><p>客户端前面的操作和服务端是一模一样的，这里不再重复填写了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.36.2_linux_amd64.tar</span><br><span class="line">cd frp_0.36.2_linux_amd64/</span><br><span class="line">rm -f frps</span><br><span class="line">rm -f frps.ini</span><br><span class="line">vi frpc.ini</span><br></pre></td></tr></table></figure>

<p>frpc.ini内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 17000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.31.101</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 16000</span><br></pre></td></tr></table></figure>

<p>上面的配置和服务端是对应的。</p>
<p><code>[common]</code>中的<code>server_addr</code>填frp服务端的ip（也就是外网主机的IP），<code>server_port</code>填frp服务端的<code>bind_prot</code>。</p>
<p><code>[ssh]</code>中的<code>local_port</code>填群晖的ssh端口。</p>
<p>保存配置，使用以下指令后台启动frp客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./frpc -c ./frpc.ini &amp;</span><br></pre></td></tr></table></figure>

<p>PS:</p>
<p>如果咱们使用阿里云或者腾讯云之类的云上服务器，记得在安全策略开放 <code>17000</code>和<code>16000</code>端口哦，不然这边也无法进行访问的~</p>
<p>参考：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p>
]]></content>
      <categories>
        <category>nginx</category>
        <category>centos</category>
        <category>frp</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>centos</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx与安全有关的几个配置</title>
    <url>/guoliangjun.github.io/1747/</url>
    <content><![CDATA[<h3 id="隐藏版本号"><a href="#隐藏版本号" class="headerlink" title="隐藏版本号"></a>隐藏版本号</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经常会有针对某个版本的nginx安全漏洞出现，隐藏nginx版本号就成了主要的安全优化手段之一，当然最重要的是及时升级修复漏洞.</p>
<span id="more"></span>

<h3 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ops-coffee.cn;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/server.key;</span><br><span class="line">    <span class="attribute">ssl_protocols</span>       TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ssl on：</strong>开启https</p>
<p><strong>ssl_certificate：</strong>配置nginx ssl证书的路径</p>
<p><strong>ssl_certificate_key：</strong>配置nginx ssl证书key的路径</p>
<p><strong>ssl_protocols：</strong>指定客户端建立连接时使用的ssl协议版本，如果不需要兼容TSLv1，直接去掉即可</p>
<p><strong>ssl_ciphers：</strong>指定客户端连接时所使用的加密算法，你可以再这里配置更高安全的算法</p>
<h3 id="添加黑白名单"><a href="#添加黑白名单" class="headerlink" title="添加黑白名单"></a>添加黑白名单</h3><p>白名单配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /admin/ &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">192.168.1.0</span>/<span class="number">24</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边表示只允许192.168.1.0/24网段的主机访问，拒绝其他所有</p>
<p>也可以写成黑名单的方式禁止某些地址访问，允许其他所有，例如</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /ops-coffee/ &#123;</span><br><span class="line">    <span class="attribute">deny</span>   <span class="number">192.168.1.0</span>/<span class="number">24</span>;</span><br><span class="line">    <span class="attribute">allow</span>    all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多的时候客户端请求会经过层层代理，我们需要通过<code>$http_x_forwarded_for</code>来进行限制，可以这样写</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">set</span> $allow <span class="literal">false</span>;</span><br><span class="line"><span class="attribute">if</span> ($http_x_forwarded_for = <span class="string">&quot;211.144.204.2&quot;</span>) &#123; <span class="attribute">set</span> $allow <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> ($http_x_forwarded_for <span class="regexp">~ &quot;108.2.66.[89]&quot;)</span> &#123; <span class="attribute">set</span> $allow <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="attribute">if</span> ($allow = <span class="literal">false</span>) &#123; <span class="attribute">return</span> <span class="number">404</span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制请求方法"><a href="#限制请求方法" class="headerlink" title="限制请求方法"></a>限制请求方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($request_method !~ ^(GET|POST)$ ) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$request_method</code>能够获取到请求nginx的method</p>
<p>配置只允许GET\POST方法访问，其他的method返回405</p>
<h3 id="拒绝User-Agent"><a href="#拒绝User-Agent" class="headerlink" title="拒绝User-Agent"></a>拒绝User-Agent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~* LWP::Simple|BBBike|wget|curl) &#123;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有一些不法者会利用wget/curl等工具扫描我们的网站，我们可以通过禁止相应的user-agent来简单的防范</p>
<p>Nginx的444状态比较特殊，如果返回444那么客户端将不会收到服务端返回的信息，就像是网站无法连接一样</p>
<h3 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    valid_referers none blocked www.199604.com 199604.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return  403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>valid_referers：</strong>验证referer，其中<code>none</code>允许referer为空，<code>blocked</code>允许不带协议的请求，除了以上两类外仅允许referer为<a href="http://www.199604.com或199604.com时访问images下的图片资源,否则返回403/">www.199604.com或199604.com时访问images下的图片资源，否则返回403</a></p>
<p>当然你也可以给不符合referer规则的请求重定向到一个默认的图片，比如下边这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    valid_referers blocked www.199604.com 199604.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        rewrite ^/images/.*\.(gif|jpg|jpeg|png)$ /static/qrcode.jpg last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制并发连接数"><a href="#控制并发连接数" class="headerlink" title="控制并发连接数"></a>控制并发连接数</h3><p>可以通过<code>ngx_http_limit_conn_module</code>模块限制一个IP的并发连接数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone=ops:10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  199604.com;</span><br><span class="line"></span><br><span class="line">        root /home/project/webapp;</span><br><span class="line">        index index.html;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            limit_conn ops 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        access_log  /tmp/nginx_access.log  main;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>limit_conn_zone：</strong>设定保存各个键(例如<code>$binary_remote_addr</code>)状态的共享内存空间的参数，zone=空间名字:大小</p>
<p>大小的计算与变量有关，例如<code>$binary_remote_addr</code>变量的大小对于记录IPV4地址是固定的4 bytes，而记录IPV6地址时固定的16 bytes，存储状态在32位平台中占用32或者64 bytes，在64位平台中占用64 bytes。1m的共享内存空间可以保存大约3.2万个32位的状态，1.6万个64位的状态</p>
<p><strong>limit_conn：</strong>指定一块已经设定的共享内存空间(例如name为<code>ops</code>的空间)，以及每个给定键值的最大连接数</p>
<p>上边的例子表示同一IP同一时间只允许10个连接</p>
<p>当有多个<code>limit_conn</code>指令被配置时，所有的连接数限制都会生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone=ops:10m;</span><br><span class="line">    limit_conn_zone $server_name zone=coffee:10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  199604.com;</span><br><span class="line"></span><br><span class="line">        root /home/project/webapp;</span><br><span class="line">        index index.html;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            limit_conn ops 10;</span><br><span class="line">            limit_conn coffee 2000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的配置不仅会限制单一IP来源的连接数为10，同时也会限制单一虚拟服务器的总连接数为2000</p>
<h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><p><strong>缓冲区溢出攻击</strong>是通过将数据写入缓冲区并超出缓冲区边界和重写内存片段来实现的，限制缓冲区大小可有效防止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_body_buffer_size  1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br></pre></td></tr></table></figure>

<p><strong>client_body_buffer_size：</strong>默认8k或16k，表示客户端请求body占用缓冲区大小。如果连接请求超过缓存区指定的值，那么这些请求实体的整体或部分将尝试写入一个临时文件。</p>
<p><strong>client_header_buffer_size：</strong>表示客户端请求头部的缓冲区大小。绝大多数情况下一个请求头不会大于1k，不过如果有来自于wap客户端的较大的cookie它可能会大于 1k，Nginx将分配给它一个更大的缓冲区，这个值可以在<code>large_client_header_buffers</code>里面设置</p>
<p><strong>client_max_body_size：</strong>表示客户端请求的最大可接受body大小，它出现在请求头部的Content-Length字段， 如果请求大于指定的值，客户端将收到一个”Request Entity Too Large” (413)错误，通常在上传文件到服务器时会受到限制</p>
<p><strong>large_client_header_buffers</strong>表示一些比较大的请求头使用的缓冲区数量和大小，默认一个缓冲区大小为操作系统中分页文件大小，通常是4k或8k，请求字段不能大于一个缓冲区大小，如果客户端发送一个比较大的头，nginx将返回”Request URI too large” (414)，请求的头部最长字段不能大于一个缓冲区，否则服务器将返回”Bad request” (400)</p>
<p>同时需要修改几个超时时间的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_body_timeout   10;</span><br><span class="line">client_header_timeout 10;</span><br><span class="line">keepalive_timeout     5 5;</span><br><span class="line">send_timeout          10;</span><br></pre></td></tr></table></figure>

<p><strong>client_body_timeout：</strong>表示读取请求body的超时时间，如果连接超过这个时间而客户端没有任何响应，Nginx将返回”Request time out” (408)错误</p>
<p><strong>client_header_timeout：</strong>表示读取客户端请求头的超时时间，如果连接超过这个时间而客户端没有任何响应，Nginx将返回”Request time out” (408)错误</p>
<p><strong>keepalive_timeout：</strong>参数的第一个值表示客户端与服务器长连接的超时时间，超过这个时间，服务器将关闭连接，可选的第二个参数参数表示Response头中Keep-Alive: timeout=time的time值，这个值可以使一些浏览器知道什么时候关闭连接，以便服务器不用重复关闭，如果不指定这个参数，nginx不会在应Response头中发送Keep-Alive信息</p>
<p><strong>send_timeout：</strong>表示发送给客户端应答后的超时时间，Timeout是指没有进入完整established状态，只完成了两次握手，如果超过这个时间客户端没有任何响应，nginx将关闭连接</p>
<h3 id="Header头设置"><a href="#Header头设置" class="headerlink" title="Header头设置"></a>Header头设置</h3><p>通过以下设置可有效防止XSS攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>X-Frame-Options：</strong>响应头表示是否允许浏览器加载frame等属性，有三个配置<code>DENY</code>禁止任何网页被嵌入,<code>SAMEORIGIN</code>只允许本网站的嵌套,<code>ALLOW-FROM</code>允许指定地址的嵌套</p>
<p><strong>X-XSS-Protection：</strong>表示启用XSS过滤（禁用过滤为<code>X-XSS-Protection: 0</code>），<code>mode=block</code>表示若检查到XSS攻击则停止渲染页面</p>
<p><strong>X-Content-Type-Options：</strong>响应头用来指定浏览器对未指定或错误指定<code>Content-Type</code>资源真正类型的猜测行为，nosniff 表示不允许任何猜测</p>
<p>在通常的请求响应中，浏览器会根据<code>Content-Type</code>来分辨响应的类型，但当响应类型未指定或错误指定时，浏览会尝试启用MIME-sniffing来猜测资源的响应类型，这是非常危险的</p>
<p>例如一个.jpg的图片文件被恶意嵌入了可执行的js代码，在开启资源类型猜测的情况下，浏览器将执行嵌入的js代码，可能会有意想不到的后果</p>
<p>另外还有几个关于请求头的安全配置需要注意</p>
<p><strong>Content-Security-Policy：</strong>定义页面可以加载哪些资源，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>上边的配置会限制所有的外部资源，都只能从当前域名加载，其中<code>default-src</code>定义针对所有类型资源的默认加载策略，<code>self</code>允许来自相同来源的内容</p>
<p><strong>Strict-Transport-Security：</strong>会告诉浏览器用HTTPS协议代替HTTP来访问目标站点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;;</span><br></pre></td></tr></table></figure>

<p>上边的配置表示当用户第一次访问后，会返回一个包含了<code>Strict-Transport-Security</code>响应头的字段，这个字段会告诉浏览器，在接下来的31536000秒内，当前网站的所有请求都使用https协议访问，参数<code>includeSubDomains</code>是可选的，表示所有子域名也将采用同样的规则</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令大全</title>
    <url>/guoliangjun.github.io/1745/</url>
    <content><![CDATA[<h5 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><strong>系统信息</strong></h5><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p>
<span id="more"></span>

<h5 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a><strong>关机 (系统的关机、重启以及登出 )</strong></h5><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p>
<h5 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a><strong>文件和目录</strong></h5><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码</p>
<h5 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a><strong>文件搜索</strong></h5><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<h5 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a><strong>挂载一个文件系统</strong></h5><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
<h5 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a><strong>磁盘空间</strong></h5><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
<h5 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a><strong>用户和群组</strong></h5><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<h5 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h5><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位</p>
<h5 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h5><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性</p>
<h5 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a><strong>打包和压缩文件</strong></h5><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p>
<h5 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong></h5><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p>
<h5 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong></h5><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p>
<h5 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong></h5><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p>
<h5 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong></h5><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p>
<h5 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a><strong>查看文件内容</strong></h5><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<h5 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a><strong>文本处理</strong></h5><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<h5 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a><strong>字符设置和文件格式转换</strong></h5><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p>
<h5 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a><strong>文件系统分析</strong></h5><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<h5 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a><strong>初始化一个文件系统</strong></h5><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p>
<h5 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a><strong>SWAP文件系统</strong></h5><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p>
<h5 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a><strong>网络 - （以太网和WIFI无线</strong>）</h5><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
