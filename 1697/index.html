<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;199604.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="不知道你们看过这个段子没反正就重视sql的程序员都很水  一、基本概念1.主键、外键、超键、候选键超键： 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 主键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL数据库部分知识点汇总">
<meta property="og:url" content="https://199604.com/1697/index.html">
<meta property="og:site_name" content="记忆角落">
<meta property="og:description" content="不知道你们看过这个段子没反正就重视sql的程序员都很水  一、基本概念1.主键、外键、超键、候选键超键： 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 主键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qn.199604.com/typoraImg/image-20210328160114395.png">
<meta property="og:image" content="http://qn.199604.com/typoraImg/ymE9HPJ.png">
<meta property="og:image" content="http://qn.199604.com/typoraImg/RbzI0R8.jpg">
<meta property="og:image" content="http://qn.199604.com/typoraImg/9VbnDME.jpg">
<meta property="og:image" content="http://qn.199604.com/typoraImg/xAeWTSp.png">
<meta property="article:published_time" content="2021-03-28T08:38:25.000Z">
<meta property="article:modified_time" content="2021-06-10T01:36:15.143Z">
<meta property="article:author" content="郭良俊只狗">
<meta property="article:tag" content="Mysql">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qn.199604.com/typoraImg/image-20210328160114395.png">


<link rel="canonical" href="https://199604.com/1697/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;199604.com&#x2F;1697&#x2F;&quot;,&quot;path&quot;:&quot;1697&#x2F;&quot;,&quot;title&quot;:&quot;MySQL数据库部分知识点汇总&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>MySQL数据库部分知识点汇总 | 记忆角落</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?<46c2f95d60e43eb48d99ddf240e9771c>"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">记忆角落</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">生活,一半是回忆,一半是继续.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/links/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>邻居</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.主键、外键、超键、候选键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.为什么用自增列作为主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.触发器的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.什么是存储过程？用什么来调用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.存储过程的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.6.</span> <span class="nav-text">6.存储过程与函数的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E5%8F%AB%E8%A7%86%E5%9B%BE%EF%BC%9F%E6%B8%B8%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.0.7.</span> <span class="nav-text">7.什么叫视图？游标是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.0.8.</span> <span class="nav-text">8.视图的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-drop%E3%80%81truncate%E3%80%81-delete%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.9.</span> <span class="nav-text">9.drop、truncate、 delete区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E6%97%B6%E8%A1%A8%EF%BC%8C%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%A0%E9%99%A4"><span class="nav-number">1.0.10.</span> <span class="nav-text">10.什么是临时表，临时表什么时候删除?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BC%98%E5%8A%BF%E6%AF%94%E8%BE%83"><span class="nav-number">1.0.11.</span> <span class="nav-text">11.非关系型数据库和关系型数据库区别，优势比较?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%B8%AA%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="nav-number">1.0.12.</span> <span class="nav-text">12.数据库范式，根据某个场景设计数据表?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF-%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AD%89"><span class="nav-number">1.0.13.</span> <span class="nav-text">13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-varchar%E5%92%8Cchar%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.0.14.</span> <span class="nav-text">14.varchar和char的使用场景?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-SQL%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB"><span class="nav-number">1.0.15.</span> <span class="nav-text">15.SQL语言分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-like-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.16.</span> <span class="nav-text">16.like %和-的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-count-%E3%80%81count-1-%E3%80%81count-column-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.17.</span> <span class="nav-text">17.count(*)、count(1)、count(column)的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">1.0.18.</span> <span class="nav-text">18.最左前缀原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%B4%A2%E5%BC%95"><span class="nav-number">2.</span> <span class="nav-text">二、索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.什么是索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.索引的作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">2.0.3.</span> <span class="nav-text">3.索引的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%93%AA%E4%BA%9B%E5%88%97%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E3%80%81%E5%93%AA%E4%BA%9B%E4%B8%8D%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.0.4.</span> <span class="nav-text">4.哪些列适合建立索引、哪些不适合建索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AD%97%E6%AE%B5%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">2.0.5.</span> <span class="nav-text">5.什么样的字段适合建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-MySQL-B-Tree%E7%B4%A2%E5%BC%95%E5%92%8CHash%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.6.</span> <span class="nav-text">6.MySQL B+Tree索引和Hash索引的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.7.</span> <span class="nav-text">7.B树和B+树的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.0.8.</span> <span class="nav-text">8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.9.</span> <span class="nav-text">9.聚集索引和非聚集索引区别?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">三、事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.什么是事务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8CMySQL%E9%BB%98%E8%AE%A4%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-number">3.0.4.</span> <span class="nav-text">4.事务传播行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.0.5.</span> <span class="nav-text">5.嵌套事务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">4.</span> <span class="nav-text">四、存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88InnoDB%E3%80%81MyISAM%E3%80%81MEMORY%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.0.1.</span> <span class="nav-text">1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">4.0.2.</span> <span class="nav-text">2.MySQL存储引擎MyISAM与InnoDB如何选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-MySQL%E7%9A%84MyISAM%E4%B8%8EInnoDB%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%9C%A8%EF%BC%8C%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.0.3.</span> <span class="nav-text">3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8A%E6%96%B9%E9%9D%A2"><span class="nav-number">4.0.3.1.</span> <span class="nav-text">事务处理上方面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%BA%A7%E5%88%AB"><span class="nav-number">4.0.3.2.</span> <span class="nav-text">锁级别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BC%98%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">五、优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%EF%BC%88where%E3%80%81jion%E3%80%81limit%E3%80%81group-by%E3%80%81having%E7%AD%89%E7%AD%89%EF%BC%89%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.0.1.</span> <span class="nav-text">1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8explain%E4%BC%98%E5%8C%96sql%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">5.0.2.</span> <span class="nav-text">2.使用explain优化sql和索引?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">5.0.3.</span> <span class="nav-text">3.MySQL慢查询怎么解决?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">六、数据库锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-mysql%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF%EF%BC%8C%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">6.0.1.</span> <span class="nav-text">1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81"><span class="nav-number">6.0.1.1.</span> <span class="nav-text">什么情况下会造成死锁?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%89%EF%BC%8Cselect-%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%A0%E6%8E%92%E5%AE%83%E9%94%81"><span class="nav-number">6.0.2.</span> <span class="nav-text">2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Lock%EF%BC%89"><span class="nav-number">6.0.2.1.</span> <span class="nav-text">悲观锁（Pessimistic Lock）:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Lock%EF%BC%89"><span class="nav-number">6.0.2.2.</span> <span class="nav-text">乐观锁（Optimistic Lock）:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">7.</span> <span class="nav-text">七、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">7.0.1.</span> <span class="nav-text">1.数据库的主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%88%86%E6%9E%90%E7%9A%84-7-%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">7.0.2.</span> <span class="nav-text">2.数据库主从复制分析的 7 个问题?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9Amaster%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%8Cslaves%E8%A2%AB%E5%8A%A8%E7%9A%84%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E9%82%A3%E4%B9%88slave%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BB%E5%8A%A8%E7%9A%84%E8%BF%9B%E8%A1%8C%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">7.0.2.1.</span> <span class="nav-text">问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9C%89N%E4%B8%AAslave-%E5%8F%AF%E6%98%AF%E8%BF%99%E4%BA%9Bslave%E5%8F%88%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A6%81%E4%BB%96%E4%BB%AC%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="nav-number">7.0.2.2.</span> <span class="nav-text">问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD%E6%9C%89master-slave1-slave2-%E2%80%A6%E7%AD%89%E7%AD%89%E8%BF%99%E4%B9%88%E5%A4%9AMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E9%82%A3%E6%AF%94%E5%A6%82%E4%B8%80%E4%B8%AAJAVA-WEB%E5%BA%94%E7%94%A8%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E8%BF%9E%E6%8E%A5%E5%93%AA%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">7.0.2.3.</span> <span class="nav-text">问题3：主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%984%EF%BC%9A%E5%A6%82%E6%9E%9CMySQL-proxy-direct-master%E4%BB%96%E4%BB%AC%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">7.0.2.4.</span> <span class="nav-text">问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%985%EF%BC%9A%E5%BD%93master%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%AF%8F%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%8C%E9%83%BD%E9%9C%80%E8%A6%81%E5%8F%91%E5%BE%80slave%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%9C%89N%E4%B8%AAslave-%E9%82%A3%E6%98%AF%E5%8F%91N%E6%AC%A1%EF%BC%8C%E8%BF%98%E6%98%AF%E5%8F%AA%E5%8F%91%E4%B8%80%E6%AC%A1%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E5%8F%91%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%8F%91%E7%BB%99%E4%BA%86slave-1%EF%BC%8C%E9%82%A3slave-2-slave-3-%E2%80%A6%E5%AE%83%E4%BB%AC%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">7.0.2.5.</span> <span class="nav-text">问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%986%EF%BC%9A%E5%BD%93%E4%B8%80%E4%B8%AAselect%E5%8F%91%E5%BE%80MySQL-proxy%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%BF%99%E6%AC%A1%E7%94%B1slave-2%E5%93%8D%E5%BA%94%EF%BC%8C%E4%B8%8B%E6%AC%A1%E7%94%B1slave-3%E5%93%8D%E5%BA%94%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E6%97%A0%E6%B3%95%E5%88%A9%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BA%86%E3%80%82"><span class="nav-number">7.0.2.6.</span> <span class="nav-text">问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%987%EF%BC%9A%E9%9A%8F%E7%9D%80%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%A5%E7%9B%8A%E5%A2%9E%E9%95%BF%EF%BC%8C%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%89%A9%E5%B1%95slave%EF%BC%8C%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9Cmaster%E6%BB%A1%E8%B6%B3%E4%B8%8D%E4%BA%86%E5%86%99%E6%93%8D%E4%BD%9C%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F"><span class="nav-number">7.0.2.7.</span> <span class="nav-text">问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-mysql-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">7.0.3.</span> <span class="nav-text">3.mysql 高并发环境解决方案?</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭良俊只狗"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">郭良俊只狗</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">392</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">255</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://gitee.com/guoliangjun17" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;guoliangjun17" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:admin@199604.com" title="E-Mail → mailto:admin@199604.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/jiomer" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;jiomer" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://199604.com/1697/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="郭良俊只狗">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记忆角落">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL数据库部分知识点汇总
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-28 16:38:25" itemprop="dateCreated datePublished" datetime="2021-03-28T16:38:25+08:00">2021-03-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 09:36:15" itemprop="dateModified" datetime="2021-06-10T09:36:15+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>不知道你们看过这个段子没<del>反正就重视sql的程序员都很水</del> <img src="http://qn.199604.com/typoraImg/image-20210328160114395.png" alt="image-20210328160114395"></p>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><p><strong>超键：</strong> 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 <strong>候选键：</strong> 是最小超键，即没有冗余元素的超键。 <strong>主键：</strong> 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 <strong>外键：</strong> 在一个表中存在的另一个表的主键称此表的外键。</p>
<h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、 如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、 如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<h4 id="3-触发器的作用"><a href="#3-触发器的作用" class="headerlink" title="3.触发器的作用"></a><strong>3.触发器的作用</strong></h4><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 <strong>调用：</strong> 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。</p>
<h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><p><strong>优点：</strong> 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 <strong>缺点：</strong>移植性差</p>
<h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="http://qn.199604.com/typoraImg/ymE9HPJ.png" alt="img"></p>
<h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><p><strong>视图：</strong> 是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 <strong>游标：</strong> 是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><p><strong>优点：</strong></p>
<ol>
<li> 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</li>
<li> 用户通过简单的查询可以从复杂查询中得到结果。</li>
<li> 维护数据的独立性，试图可从多个表检索数据。</li>
<li> 对于相同的数据可产生不同的视图。</li>
</ol>
<p><strong>缺点：</strong> 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么就无法更改数据</p>
<h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><p><strong>最基本：</strong></p>
<ul>
<li>  drop直接删掉表。</li>
<li>  truncate删除表中数据，再插入时自增长id又从1开始。</li>
<li>  delete删除表中数据，可以加where字句。</li>
</ul>
<ol>
<li> DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li>
<li> 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li>
<li> 一般而言，drop &gt; truncate &gt; delete</li>
<li> 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</li>
<li> TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</li>
<li> truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li>
<li> delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li>
<li> truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</li>
<li> 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</li>
<li> Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li>
<li> TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</li>
<li> 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</li>
</ol>
<h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><p><strong>临时表可以手动删除：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TEMPORARY TABLE IF EXISTS temp_tb;</span><br></pre></td></tr></table></figure>

<p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。 创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong> 如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE tmp_table (</span><br><span class="line"></span><br><span class="line">NAME VARCHAR (10) NOT NULL,</span><br><span class="line"></span><br><span class="line">time date NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select * from tmp_table;</span><br></pre></td></tr></table></figure>

<h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><p><strong>非关系型数据库的优势：</strong></p>
<ul>
<li>  <strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>  <strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</ul>
<p><strong>关系型数据库的优势：</strong></p>
<ul>
<li>  <strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>  <strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
<p><strong>其他：</strong> **1.**对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 **2.**NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。 **3.**对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p>
<h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><p>第一范式:(确保每列保持原子性)所有字段值都是不可分解的原子值。 <strong>第一范式是最基本的范式。</strong> 如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 <strong>第一范式的合理遵循需要根据系统的实际需求来定。</strong> 比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。 第二范式:(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 <strong>第二范式在第一范式的基础之上更进一层。</strong> 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。 第三范式:(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。 <strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong> 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。 <strong>BCNF:符合3NF，并且，主属性不依赖于主属性。</strong> 若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。 通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。 BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。 还可以这么说：<strong>若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。</strong> 一般，一个数据库设计符合3NF或BCNF就可以了。 第四范式:要求把同一表内的多对多关系删除。 第五范式:从最终结构重新建立原始结构。 深入可看知乎大神解答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366">https://www.zhihu.com/question/24696366</a></p>
<h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><p><strong>内连接:</strong> 只连接匹配的行 <strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 <strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 例如1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*,b.* FROM roletable LEFT JOIN usertable as b ON a.username=b.username</span><br></pre></td></tr></table></figure>

<p>例如2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*,b.* FROM city as a RIGHT OUTER JOIN user as b ON a.username=b.username</span><br></pre></td></tr></table></figure>

<p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 <strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接： 牛客网–<a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/sql">https://www.nowcoder.com/ta/sql</a> 力扣–<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/database/">https://leetcode-cn.com/problemset/database/</a></p>
<h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><ol>
<li> char的长度是不可变的，而varchar的长度是可变的。</li>
<li> 定义一个char[10]和varchar[10]。 如果存进去的是‘glj’,那么char所占的长度依然为10，除了字符‘glj’外，后面跟7个空格，varchar就立马把长度变为3了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</li>
<li> char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。 char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。 varchar是以空间效率为首位。</li>
<li> char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。 varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</li>
<li> 两者的存储数据都非unicode的字符数据。</li>
</ol>
<h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><p><strong>SQL语言共分为四大类：</strong></p>
<ul>
<li>  数据查询语言DQL</li>
<li>  数据操纵语言DML</li>
<li>  数据定义语言DDL</li>
<li>  数据控制语言DCL。</li>
</ul>
<p><strong>1. 数据查询语言DQL</strong> 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块： SELECT FROM WHERE <strong>2 .数据操纵语言DML</strong> 数据操纵语言DML主要有三种形式：</p>
<ol>
<li> 插入：INSERT</li>
<li> 更新：UPDATE</li>
<li> 删除：DELETE</li>
</ol>
<p><strong>3. 数据定义语言DDL</strong> 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如： CREATE TABLE/VIEW/INDEX/SYN/CLUSTER 表 视图 索引 同义词 簇 DDL操作是隐性提交的！不能rollback <strong>4. 数据控制语言DCL</strong> 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ol>
<li> GRANT：授权。</li>
<li> ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为： SQL&gt;ROLLBACK;</li>
<li> COMMIT [WORK]：提交。</li>
</ol>
<p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。 提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。 (1) 显式提交 用COMMIT命令直接完成的提交为显式提交。其格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span><span class="keyword">COMMIT</span>；</span><br></pre></td></tr></table></figure>

<p>(2) 隐式提交 用SQL命令间接完成的提交为隐式提交。这些命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</span><br></pre></td></tr></table></figure>

<p>(3) 自动提交 若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span><span class="keyword">SET</span> AUTOCOMMIT <span class="keyword">ON</span>；</span><br></pre></td></tr></table></figure>

<h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><p><strong>通配符的分类:</strong> **%百分号通配符:**表示任何字符出现任意次数(可以是0次). **_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符. <strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较. <strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE products.prod_name like &#x27;1000&#x27;;</span><br></pre></td></tr></table></figure>

<p>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果. <strong>%通配符使用:</strong> 匹配以”yves”开头的记录:(包括记录”yves”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM products WHERE products.prod_name like &#x27;yves%&#x27;;</span><br></pre></td></tr></table></figure>

<p>匹配包含”yves”的记录(包括记录”yves”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT* FROM products WHERE products.prod_name like &#x27;%yves%&#x27;;</span><br></pre></td></tr></table></figure>

<p>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE products.prod_name like &#x27;%yves&#x27;;</span><br></pre></td></tr></table></figure>

<p>*通配符使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT \*FROM products WHERE products.prod_name like &#x27;_yves&#x27;; </span><br></pre></td></tr></table></figure>

<p>匹配结果为: 像”yyves”这样记录.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT\* FROM products WHERE products.prod\*name like &#x27;yves**&#x27;; </span><br></pre></td></tr></table></figure>

<p>匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少) <strong>注意事项:</strong></p>
<ul>
<li>  注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__“这样的匹配条件匹配的.</li>
<li>  注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li>
<li>  注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li>
</ul>
<p><strong>技巧与建议:</strong> 正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p>
<ul>
<li>  不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li>
<li>  在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li>
<li>  仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li>
</ul>
<p>参考博文： <em><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></em></p>
<h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><ul>
<li>  count(*)对行的数目进行计算,包含NULL</li>
<li>  count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li>
<li>  count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li>
</ul>
<p><strong>性能问题:</strong> 1.任何情况下SELECT COUNT(*) FROM tablename是最优选择; 2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询; 3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p>
<ul>
<li>  如果表没有主键,那么count(1)比count(*)快。</li>
<li>  如果有主键,那么count(主键,联合主键)比count(*)快。</li>
<li>  如果表只有一个字段,count(*)最快。</li>
</ul>
<p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p>
<h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><p><strong>多列索引：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</span><br></pre></td></tr></table></figure>

<p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。 注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。 <strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p>
<h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><p><strong>何为索引：</strong> 数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h4 id="2-索引的作用？"><a href="#2-索引的作用？" class="headerlink" title="2.索引的作用？"></a><strong>2.索引的作用？</strong></h4><p><strong>索引作用：</strong> 协助快速查询、更新数据库表中数据。 为表设置索引要付出代价的：</p>
<ul>
<li>  一是增加了数据库的存储空间</li>
<li>  二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)</li>
</ul>
<h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4><p><strong>创建索引可以大大提高系统的性能（优点）：</strong> 1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 <strong>增加索引也有许多不利的方面(缺点)：</strong> 1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 <strong>一般来说，应该在这些列上创建索引：</strong> （1）在经常需要搜索的列上，可以加快搜索的速度； （2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； （3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； （4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； （5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； （6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 <strong>对于有些列不应该创建索引：</strong> （1）对于那些在查询中很少使用或者参考的列不应该创建索引。 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 （2）对于那些只有很少数据值的列也不应该增加索引。 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 （3）对于那些定义为text, image和bit数据类型的列不应该增加索引。 这是因为，这些列的数据量要么相当大，要么取值很少。 (4)当修改性能远远大于检索性能时，不应该创建索引。 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><p>唯一、不为空、经常被查询的字段</p>
<h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p>
<ul>
<li>  Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li>
<li>  B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li>
</ul>
<p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p>
<ol>
<li> Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li>
<li> Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li>
<li> Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li>
<li> Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li>
<li> Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li>
</ol>
<p><strong>补充：</strong> 1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。 2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。 B+树索引和哈希索引的明显区别是： 3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据； 4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索； 同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）； 5.哈希索引也不支持多列联合索引的最左匹配规则； 6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p>
<h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><ol>
<li> B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li>
</ol>
<p><img src="http://qn.199604.com/typoraImg/RbzI0R8.jpg" alt="img"></p>
<ol start="2">
<li> B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</li>
</ol>
<p><img src="http://qn.199604.com/typoraImg/9VbnDME.jpg" alt="img"></p>
<h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><p><strong>1. B+的磁盘读写代价更低</strong> B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 <strong>2. B+tree的查询效率更加稳定</strong> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><p><strong>聚合索引(clustered index):</strong> 聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。 聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a<del>z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。 <strong>非聚合索引(nonclustered index):</strong> 非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。 非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a</del>z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。 <strong>根本区别：</strong> 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p>
<h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><p><strong>原子性（Atomicity）:</strong> 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 <strong>一致性（Consistency）:</strong> 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。 <strong>隔离性（Isolation）:</strong> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 <strong>持久性（Durability）:</strong> 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。 <strong>事务的并发问题</strong> <strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 <strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。 <strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。 例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 <strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong> <strong>事务的隔离级别</strong>： <img src="http://qn.199604.com/typoraImg/xAeWTSp.png" alt="img"> <strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读 <strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。 <strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象 <strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样 <strong>特别注意：</strong></p>
<blockquote>
<p>MySQL默认的事务隔离级别为repeatable-read MySQL 支持 4 中事务隔离级别. 事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持. Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异 <strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong> <strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。 <strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。 <strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
</blockquote>
<h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。 <strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。 <strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。 <strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。 <strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 <strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。 <strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
<h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><p><strong>什么是嵌套事务？</strong> 嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了： <strong>如果子事务回滚，会发生什么？</strong> 父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。 <strong>如果父事务回滚，会发生什么？</strong> 父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么： <strong>事务的提交，是什么情况？</strong> 是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><p><strong>两种存储引擎的大致区别表现在：</strong> 1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。 2.MyISAM适合查询以及插入为主的应用。 3.InnoDB适合频繁修改以及涉及到安全性较高的应用。 4.InnoDB支持外键，MyISAM不支持。 5.从MySQL5.5.5以后，InnoDB是默认引擎。 6.InnoDB不支持FULLTEXT类型的索引。 7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。 8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。 9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。 10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p>
<h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。 虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。 关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p>
<ul>
<li>  INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li>
<li>  MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li>
</ul>
<h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><h5 id="事务处理上方面"><a href="#事务处理上方面" class="headerlink" title="事务处理上方面"></a><strong>事务处理上方面</strong></h5><ul>
<li>  MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li>
<li>  InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
</ul>
<h5 id="锁级别"><a href="#锁级别" class="headerlink" title="锁级别"></a><strong>锁级别</strong></h5><ul>
<li>  MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li>
<li>  InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li>
</ul>
<h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><p>查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></p>
<blockquote>
<p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong> **from:**需要从哪个数据表检索数据 **where:**过滤表中数据的条件 **group by:**如何将上面过滤出的数据分组 **having:**对上面已经分组的数据进行过滤的条件 **select:**查看结果集中的哪个列，或列的计算结果 **order by :**按照什么样的顺序来查看返回的数据</p>
</blockquote>
<p><strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong> 也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p>
<h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong> <strong>table：</strong>显示这一行的数据是关于哪张表的 <strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL **all:**full table scan ;MySQL将遍历全表以找到匹配的行； <strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引； <strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询； <strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找； <strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描； <strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。 <strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 <strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引 <strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好 <strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数 <strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数 <strong>Extra：</strong>关于MySQL如何解析查询的额外信息。</p>
<h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><ul>
<li>  slow_query_log 慢查询开启状态。</li>
<li>  slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li>
<li>  long_query_time 查询超过多少秒才记录。</li>
</ul>
<h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p>
<ul>
<li>  <strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>  <strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>  <strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h5 id="什么情况下会造成死锁"><a href="#什么情况下会造成死锁" class="headerlink" title="什么情况下会造成死锁?"></a><strong>什么情况下会造成死锁?</strong></h5><p><strong>什么是死锁？</strong> <strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。 表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。 <strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。 那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。 <strong>死锁的解决办法?</strong> 1.查出的线程杀死 kill</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure>

<p>2.设置锁的超时时间 Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。 生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值 该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下： set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。 3.指定获取锁的顺序</p>
<h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><h5 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）:"></a><strong>悲观锁（Pessimistic Lock）:</strong></h5><p><strong>悲观锁特点:<strong>先获取锁，再进行业务操作。 即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的</strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 <strong>补充：</strong> 不同的数据库对select for update的实现和支持都是有所区别的，</p>
<ul>
<li>  oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li>
<li>  MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li>
</ul>
<h5 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）:"></a><strong>乐观锁（Optimistic Lock）:</strong></h5><p><strong>1.<strong>乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。 <strong>2.乐观锁的特点先进行业务操作，不到万不得已不去拿锁。</strong>即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。 乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。 <strong>3.<strong>一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>， <strong>实现方式举例如下：</strong> <strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是</strong>数据库实现乐观锁的一种方式</strong>。</p>
<ol>
<li> SELECT data AS old_data, version AS old_version FROM …;</li>
<li> 根据获取的数据进行业务操作，得到new_data和new_version</li>
<li> UPDATE SET data = new_data, version = new_version WHERE version = old_version</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (updated row &gt; 0) &#123;</span><br><span class="line">// 乐观锁获取成功，操作完成</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 乐观锁获取失败，回滚并重试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>  乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>  乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li>
</ul>
<p><strong>总结：</strong> 悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<ul>
<li>  <strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。</li>
<li>  <strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li>
<li>  <strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li>
</ul>
<h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><p><strong>主从复制的几种方式:</strong> <strong>同步复制:</strong> 所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。 <strong>异步复制:</strong> 如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。 <strong>半同步复制:</strong> master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p>
<h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><h5 id="问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？"><a href="#问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？" class="headerlink" title="问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？"></a><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</h5><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p>
<h5 id="问题2：主从复制中，可以有N个slave-可是这些slave又不能进行写操作，要他们干嘛？"><a href="#问题2：主从复制中，可以有N个slave-可是这些slave又不能进行写操作，要他们干嘛？" class="headerlink" title="问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？"></a><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</h5><p><strong>实现数据备份:</strong> 类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。 **异地容灾:**比如master在北京，地震挂了，那么在上海的slave还可以继续。 主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。</p>
<h5 id="问题3：主从复制中有master-slave1-slave2-…等等这么多MySQL数据库，那比如一个JAVA-WEB应用到底应该连接哪个数据库"><a href="#问题3：主从复制中有master-slave1-slave2-…等等这么多MySQL数据库，那比如一个JAVA-WEB应用到底应该连接哪个数据库" class="headerlink" title="问题3：主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?"></a><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</h5><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作， select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。 这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？ 找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。 MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。 这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p>
<h5 id="问题4：如果MySQL-proxy-direct-master他们中的某些挂了怎么办？"><a href="#问题4：如果MySQL-proxy-direct-master他们中的某些挂了怎么办？" class="headerlink" title="问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？"></a><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</h5><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p>
<h5 id="问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave-那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2-slave-3-…它们怎么办？"><a href="#问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave-那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2-slave-3-…它们怎么办？" class="headerlink" title="问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？"></a><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</h5><p>显然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p>
<h5 id="问题6：当一个select发往MySQL-proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。"><a href="#问题6：当一个select发往MySQL-proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。" class="headerlink" title="问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。"></a><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</h5><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p>
<h5 id="问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？"><a href="#问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？" class="headerlink" title="问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？"></a><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</h5><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。 scale out ? 主从复制架构已经满足不了。 可以分库【垂直拆分】，分表【水平拆分】。</p>
<h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。 <strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。 <strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。 <strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。 <strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。 转载：<a target="_blank" rel="noopener" href="https://cnblogs.com/wenxiaofei/p/9853682.html">https://cnblogs.com/wenxiaofei/p/9853682.html</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>只想买包辣条</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/weixin.png" alt="郭良俊只狗 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/zhifubao.png" alt="郭良俊只狗 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>郭良俊只狗
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://199604.com/1697/" title="MySQL数据库部分知识点汇总">https://199604.com/1697/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"><i class="fa fa-tag"></i> Mysql</a>
              <a href="/tags/sql/" rel="tag"><i class="fa fa-tag"></i> sql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/1692/" rel="prev" title="Component, Repository, Service,Controller的区别">
                  <i class="fa fa-chevron-left"></i> Component, Repository, Service,Controller的区别
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/1700/" rel="next" title="域名报红检测小工具-python">
                  域名报红检测小工具-python <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2012 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭良俊只狗</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
